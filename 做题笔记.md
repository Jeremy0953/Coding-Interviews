# 剑指Offer算法题记录

### 1、二维数组查找

![image-20210313163335411](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210313163335411.png)

自己一上来想到的思路是模拟一维数组的二分查找找中间位置的值进行二分查找，但是有问题，没办法进行二分，于时有了新思路，从上往下一行一行遍历，在每一行中进行二分查找，这样子的时间复杂度是

$ O(mlgn) $ 但是后面看题解发现有一种更好的解决方法时间复杂度为$O(m+n)$，因为要充分利用给定数组的特点，比如从一维数组的二分查找出发，可能要有一个a\[mid\]来和target比较然后进行二分（**可以进行二分的关键是可以根据大小关系排除一部分搜索空间**）在一维的二分是可以排除左面或者右面的部分，因为**左面都小于target，右面都大于target**。

那么我们就可以在二维数组中看看是否有类似的关系，我们发现一个比如一个游标a\[row\]\[col]，那么比该数小的都在他**左上方的小矩形**范围内，比他大的在剩下的三块中，那么我们可以利用这个来进行排除一些元素，倘若从中间开始选这个游标的话，如果比他小，那么**不知道是要减小row还是减小col来改变搜索范围**，那么我们可以让其中**一个达到最大，一个达到最小**，也就是选择**左下角的点或者右下角的点**来作为初始值，这样我们在知道大小关系之后就可以有一个**确定的移动方向**，比如我们可以先选择左下角的点作为初始值，那么我们用target和这个点比较，如果比这个点小，那么就说明是在左上方的矩形里面（但是由于是从最左端开始的），也就是说在该点的上方，所以就row--就好了（搜索空间排除掉当前点所在行），如果比这个点大，那么就说明在其右侧，那么就col++（搜索空间排除掉当前点所在的列）

```java
public boolean Find(int target, int[][] array)
    //根据题解给出的答案
    {
        int row = array.length-1;
        if (array[0].length==0)
            return false;
        int col = 0;
        while (row>=0&&col<array[0].length)
        {
            if (array[row][col] == target)
                return true;
            else if (array[row][col] < target)
                col++;
            else
                row--;
        }
        return false;
    }
```

