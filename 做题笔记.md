# 剑指Offer算法题记录

### 1、二维数组查找

**题目描述**：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。



自己一上来想到的思路是模拟一维数组的二分查找找中间位置的值进行二分查找，但是有问题，没办法进行二分，于时有了新思路，从上往下一行一行遍历，在每一行中进行二分查找，这样子的时间复杂度是

$ O(mlgn) $ 但是后面看题解发现有一种更好的解决方法时间复杂度为$O(m+n)$，因为要充分利用给定数组的特点，比如从一维数组的二分查找出发，可能要有一个a\[mid\]来和target比较然后进行二分（**可以进行二分的关键是可以根据大小关系排除一部分搜索空间**）在一维的二分是可以排除左面或者右面的部分，因为**左面都小于target，右面都大于target**。

那么我们就可以在二维数组中看看是否有类似的关系，我们发现一个比如一个游标a\[row\]\[col]，那么比该数小的都在他**左上方的小矩形**范围内，比他大的在剩下的三块中，那么我们可以利用这个来进行排除一些元素，倘若从中间开始选这个游标的话，如果比他小，那么**不知道是要减小row还是减小col来改变搜索范围**，那么我们可以让其中**一个达到最大，一个达到最小**，也就是选择**左下角的点或者右下角的点**来作为初始值，这样我们在知道大小关系之后就可以有一个**确定的移动方向**，比如我们可以先选择左下角的点作为初始值，那么我们用target和这个点比较，如果比这个点小，那么就说明是在左上方的矩形里面（但是由于是从最左端开始的），也就是说在该点的上方，所以就row--就好了（搜索空间排除掉当前点所在行），如果比这个点大，那么就说明在其右侧，那么就col++（搜索空间排除掉当前点所在的列）

```java
public boolean Find(int target, int[][] array)
    //根据题解给出的答案
    {
        int row = array.length-1;
        if (array[0].length==0)
            return false;
        int col = 0;
        while (row>=0&&col<array[0].length)
        {
            if (array[row][col] == target)
                return true;
            else if (array[row][col] < target)
                col++;
            else
                row--;
        }
        return false;
    }
```

### 3、逆序输出链表

利用栈的数据结构，顺序遍历链表压栈，之后顺序弹栈即可，没什么好说的。

### 4、已知二叉树的前序遍历和中序遍历结果还原二叉树

根据前序遍历序列的**第一个结点为当前根节点**，然后在中序序列中找到该根节点，**该根结点左面的序列是左子树的中序序列，右面的序列是右子树的中序序列**，然后相应地在前序序列中划分出来相应的的左子树的序列和右子树的前序序列，然后**递归**的调用该函数构建当前结点的左儿子和右儿子。

### 6、旋转数组的最小数字

**旋转数组特点**：

1. 包含两个有序序列
2. 最小数一定位于第二个序列的开头
3. 前序列的值都大于等于后序列的值
4. 定义把一个数组最开始的若干元素搬到数组的末尾，我们称之为数组的旋转。

**题目描述**：

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

需要利用二分的思想，那么就要用**a\[mid]和某个target比较，然后去除掉一部分（或者说是可以缩小搜索范围）**

因为这道题是找最小元素，并不是搜索某个值，所以没有target，没有target的时候就可以先猜想是否可以将端点当作target，

（旋转数组的这一类型还需进一步理解）