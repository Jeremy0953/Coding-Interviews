# 算法题记录

### 4、二维数组查找

**题目描述**：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

***提一个不太有人讲的观点，站在右上角看。这个矩阵其实就像是一个Binary Search Tree。然后，聪明的大家应该知道怎么做了。***

自己一上来想到的思路是模拟一维数组的二分查找找中间位置的值进行二分查找，但是有问题，没办法进行二分，于时有了新思路，从上往下一行一行遍历，在每一行中进行二分查找，这样子的时间复杂度是

$ O(mlgn) $ 但是后面看题解发现有一种更好的解决方法时间复杂度为$O(m+n)$，因为要充分利用给定数组的特点，比如从一维数组的二分查找出发，可能要有一个a\[mid\]来和target比较然后进行二分（**可以进行二分的关键是可以根据大小关系排除一部分搜索空间**）在一维的二分是可以排除左面或者右面的部分，因为**左面都小于target，右面都大于target**。

那么我们就可以在二维数组中看看是否有类似的关系，我们发现一个比如一个游标a\[row\]\[col]，那么比该数小的都在他**左上方的小矩形**范围内，比他大的在剩下的三块中，那么我们可以利用这个来进行排除一些元素，倘若从中间开始选这个游标的话，如果比他小，那么**不知道是要减小row还是减小col来改变搜索范围**，那么我们可以让其中**一个达到最大，一个达到最小**，也就是选择**左下角的点或者右下角的点**来作为初始值，这样我们在知道大小关系之后就可以有一个**确定的移动方向**，比如我们可以先选择左下角的点作为初始值，那么我们用target和这个点比较，如果比这个点小，那么就说明是在左上方的矩形里面（但是由于是从最左端开始的），也就是说在该点的上方，所以就row--就好了（搜索空间排除掉当前点所在行），如果比这个点大，那么就说明在其右侧，那么就col++（搜索空间排除掉当前点所在的列）

```java
public boolean Find(int target, int[][] array)
    //根据题解给出的答案
    {
        int row = array.length-1;
        if (array[0].length==0)
            return false;
        int col = 0;
        while (row>=0&&col<array[0].length)
        {
            if (array[row][col] == target)
                return true;
            else if (array[row][col] < target)
                col++;
            else
                row--;
        }
        return false;
    }
```

### 3、逆序输出链表

利用栈的数据结构，顺序遍历链表压栈，之后顺序弹栈即可，没什么好说的。

### 4、已知二叉树的前序遍历和中序遍历结果还原二叉树

根据前序遍历序列的**第一个结点为当前根节点**，然后在中序序列中找到该根节点，**该根结点左面的序列是左子树的中序序列，右面的序列是右子树的中序序列**，然后相应地在前序序列中划分出来相应的的左子树的序列和右子树的前序序列，然后**递归**的调用该函数构建当前结点的左儿子和右儿子。

### 6、旋转数组的最小数字\\最大数字

**旋转数组特点**：

1. 包含两个有序序列
2. 最小数一定位于第二个序列的开头
3. 前序列的值都大于等于后序列的值
4. 定义把一个数组最开始的若干元素搬到数组的末尾，我们称之为数组的旋转。

**题目描述**：

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个**非递减排序**的数组的一个旋转，输出旋转数组的最小元素。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

需要利用二分的思想，那么就要用**a\[mid]和某个target比较，然后去除掉一部分（或者说是可以缩小搜索范围）**

因为这道题是找最小元素，并不是搜索某个值，所以没有target，没有target的时候就可以先猜想是否可以将端点当作target，那么我们可以考虑左端点或者右端点，讲道理一开始是不知道用左端点还是右端点的，我们知道旋转数组的特点，有两个有序序列，第一个有序序列都大于等于第二个有序序列，那么比如我们用右端点作为target，就用a\[mid]和target比较，如果a\[mid]>target，说明mid位于第一个序列，那么说明最小数字一定在mid右边（缩小搜索范围），所以first=mid+1，如果a\[mid]<target，说明mid位于第二个序列中，那么最小的数据可能是存在在mid以及她左面，所以last = mid，如果a\[mid] == target，那么不确定target在哪里（因为可能出现重复元素），就将last = last-1，一点点的缩小范围。

按理说用左端点可能也可以，但是问题就出现在特殊情况（a = {1,2,3,4,5}或者a = {3,4,5,1,2})，如果用左端点的话都是a\[mid]>target，但是一个最小值在左面，一个在右边，所以**求最小值用右端点**，不能用左端点

那么求最大值是不是就可以用左端点了呀

如果a\[mid]>target,那么说明mid位于第一个序列，说明最大值在mid以及mid右边，所以first = mid，如果a[mid]<target , 那么说明mid位于第二个序列，说明最大值在mid左面，所以，last = mid-1，如果a\[mid] == target,那么不确定是在左面还是在右面，就要first = first +1 逐步缩小范围。

**求最大值用左端点**，不能用右端点

#### 旋转数组的生成

1. 利用临时数组，一次遍历存储到临时数组中，二次遍历将临时数组中(i+k)%n 计算新下标
2. 利用数组翻转，先全部翻转，然后前k%n个元素翻转，然后后面元素翻转
3. 环形旋转（要用一个visit数组判断是否访问过，防止长度是k的整数倍的时候的原地打转）

#### 旋转数组题的基本套路大多都是    二分



### 7-10、都是类似斐波那契数列递归的思想

可以先想到递归，然后再看递归能不能变成循环解决（会比递归快很多）

### 11、输入一个整数，输出该数32位二进制中1的个数

正数原码的话可以直接按照转换二进制的方法，依此除以2来计算1的个数

负数反码的话可以依据负数的相反数的原码以及补码之间的小规律来做

**负数的补码是将绝对值的原码，从低位往高位数到第一个1为止，后面的都不变（包括这个1）前面的都取反**

比如**-9补码是11110111，9的原码00001001，从原码$\rightarrow$反码只需保留最后的1，前面所有取反即可**

但是看题解仿佛不是最优解

次优解，可以将输入的整数看作二进制形式，然后用0x01和这个二进制的每一位进行&运算，通过&运算来计算1的个数。**每次&运算一次后，将0x01左移一位之后再进行&运算，因为如果将给的整数右移的话可能会因为负数逻辑右移最高位补1导致答案出错**

**小技巧：可以跳过所有为0的位只看为1的位：**

现考虑二进制数：val = 1101000，val-1 = 1100111 那么val & （val-1）= 1100000

```java
int val; // input data
int ans = 0;
while (val != 0) {
    ++ans;
    val = val & (val-1);
}
```

**上面这个是最优解，时间复杂度$O(n)$，n为val中1的个数，空间复杂度是$O(1)$**

### 12、数值的整数次方

自己想的方法是可以递归进行计算，如果次方是偶数则分两半计算然后相乘，如果是奇数，则是分两半相乘然后再乘本身

时间复杂度$O(lgn)$

还有一种方法是利用二进制

![image-20210314193543540](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210314193543540.png)

